package org.cdlib.marcconvert;

import org.apache.log4j.Logger;

import org.cdlib.util.marc.MarcFixedLengthField;
import org.cdlib.util.marc.MarcVblLengthField;

/**
 * Abstract base class for conversion of MARC records generated by Innovative
 * Interfaces catalogs. Subclasses representing converters for specific
 * III institutions will extend IIIConvert.
 *
 * @author <a href="mailto:rmoon@library.berkeley.edu">Ralph Moon</a>
 * @author <a href="mailto:shawnm@splorkin.com">Shawn McGovern</a>
 * @version $Id: IIIConvert.java,v 1.7 2006/07/31 19:22:16 rkl Exp $
 */
public abstract class IIIConvert extends MarcConvert
{
	/**
	 * log4j Logger for this class.
	 */
    private static Logger log = Logger.getLogger(IIIConvert.class);

	/**
	 * CVS header string.
	 */
    public static final String cvsHeader = "$Header: /cvs/root/melvyl/ei/marcconvert/java/org/cdlib/marcconvert/IIIConvert.java,v 1.7 2006/07/31 19:22:16 rkl Exp $";

	/**
	 * CVS version string.
	 */
    public static final String version = "$Revision: 1.7 $";

	/**
	 * Private indicator used to assure CVS information is logged
	 * only once.
	 */
    private static boolean versionLogged = false;

    /*
     * Static initializer used to log cvs header info.
     */
    {
        if ( !versionLogged )
        {
            log.info(cvsHeader);
            versionLogged = true;
        }
    }

    /**
     * Numerical code for Graduate Theological Union records
     */
    protected static final int GTU = 0;

    /**
     * Numerical code for UCD Law records
     */
    protected static final int UCDL = 1;

    /**
     * Numerical code for UC Irvine records
     */
    protected static final int UCI = 2;

    /**
     * Numerical code for UC Riverside records
     */
    protected static final int UCR = 3;

    /**
     * Numerical code for UC Santa Cruz records
     */
    protected static final int UCSC = 4;

    /**
     * Numerical code for UC San Diego records
     */
    protected static final int UCSD = 5;

    /**
     * Numerical code for UC San Francisco records
     */
    protected static final int UCSF = 6;

    /**
     * The minimun allowed value for campus code.
     */
    private static final int MINIMUM_CODE = 0;

    /**
     * The maximun allowed value for campus code.
     */
    private static final int MAXIMUM_CODE = 6;

    /**
     * Numerial code for source of records being converted. This value is set
     * by the contructor and must be within the range of MINIMUM_CODE to
     * MAXIMUM_CODE as defined within this class.
     */
    private int campus;

    /**
     * Construct a new IIIConverter for the specified campus
     *
     * @param  campus Numerical code for source of records.
     *
     * @throws RuntimeException if the campus code is outside the range of
     *         allowable campus codes.
     */
    protected IIIConvert(int code)
    {
        super();

        if ( code < MINIMUM_CODE || code > MAXIMUM_CODE )
        {
            throw new RuntimeException("Unknown campus code");
        }

        campus = code;
    }

    /**
     * Returns true if the cataloging source matches that for
     * the campus requested when the constructor was called.
     * Returns false if the record lacks a 901 $a or if
     * the cataloging source doesn't match expectations.
     */
    protected boolean verifyCatalogingSource()
    {
        String v901a = inMarc.getFirstValue("901", "a");
        String requiredPrefix = prefixForThisCampus();
        if ( log.isDebugEnabled() )
        {
            log.debug("v901a = '" + v901a + "'  requiredPrefix = '" + requiredPrefix);
        }

        return ( exists(v901a)
                 && requiredPrefix != null
                 && v901a.startsWith(requiredPrefix) );
    }


    /**
     * Normalizes the record leader in the output record.
     * Presumes that the caller has moved the input
     * leader to output.
     */
    protected void normalizeLeader()
    {
        // Determine whether this is a delete record

        String v901c = inMarc.getFirstValue("901", "c");
        boolean isDelete = false;

        if (campus == UCSC)
        {
            if ( v901c.equalsIgnoreCase("d")
                 || v901c.equalsIgnoreCase("h")
                 || v901c.equalsIgnoreCase("n") )
            {
                isDelete = true;
            }
        }
        else if ( v901c.equalsIgnoreCase("d") )
        {
            isDelete = true;
        }

        // Normalize the STATUS byte of the leader

        if ( isDelete )
        {
            outMarc.setRecordStatus("d");
        }

        // Normalize the TYPE byte in the leader

        if ( inMarc.getRecordType().equalsIgnoreCase("h")
             || (campus == UCI && inMarc.getRecordType().equalsIgnoreCase("s")) )
        {
            outMarc.setRecordType("a");
        }
    }


    /**
     * Normalizes the bibliographic fields in the output record.
     * Presumes that the caller has moved all non-local input
     * fields to output.
     *
     * @exception MarcDropException No 901 $a in input record. Will
     * already have been caught if verifyCatalogingSource() is called
     * before normalizeBibFields() as it should.
     */
    protected void normalizeBibFields()
    {
        // Drop unwanted fields
        dropFields();

        // Build these fields for output
        build005();
        build035();
        build901();
    }


    /**
     * Determine if the input is a serials record.
     *
     * This is the canonical method for determining serial status of a holding.
     * All III converters must use this method to determine if a holding is a serial.
     *
     * @return true if the current record is a serials record
     */
    protected boolean isSerial()
    {
        String type     = outMarc.getRecordType();
        String biblevel = outMarc.getBibLvl();

        // Special cases
        if (campus == UCR || campus == UCSC || campus == UCSD)
        {
            if ( (type.equalsIgnoreCase("a") || type.equalsIgnoreCase("m"))
                 && (biblevel.equalsIgnoreCase("b") || biblevel.equalsIgnoreCase("i")
		|| biblevel.equalsIgnoreCase("s")) )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        // Everyone else
        if ( type.equalsIgnoreCase("a")
             && (biblevel.equalsIgnoreCase("b") || biblevel.equalsIgnoreCase("i")
		|| biblevel.equalsIgnoreCase("s")) )
        {
            return true;
        }
        else
        {
            return false;
        }
    }


    /**
     * Determine if the input is a monograph record.
     * The rule is: all that is not serial is monograph, so we just
     * return the inversion of <code>isSerial()</code>.
     *
     * This is the canonical method for determining monograph status of a holding.
     * All III converters must use this method to determine if a holding is a monograph.
     *
     * @return true if the current record is a monograph record
     */
    protected boolean isMonograph()
    {
        return !isSerial();
    }


    //====================================================
    //       PRIVATE
    //====================================================

    /**
     * Return the cataloging source prefix for the campus
     * specified when the constructor was called to create
     * this instance.
     *
     * @return cataloging source prefix for this campus
     * E.g., "UCSD", "UCSF", etc., or null if campus is unknown.
     */
     private String prefixForThisCampus()
     {
        String prefix;
        switch ( campus )
        {
        case UCDL:
            prefix = "UCDL"; break;
        case UCSC:
            prefix = "UCSC"; break;
        case UCSD:
            prefix = "UCSD"; break;
        case UCSF:
            prefix = "UCSF"; break;
        case GTU:
            prefix = "GTU"; break;
        case UCI:
            prefix = "UCI"; break;
        case UCR:
            prefix = "UCR"; break;
        default:
            throw new RuntimeException("Unknown campus");
        }
        return prefix;
    }

    /**
     * Drop unwanted fields from output
     */
    private void dropFields()
    {
        // Drop 000-004
        outMarc.deleteFields("000", "004");

        // Drop 005
        outMarc.deleteFields("005");

        // Drop 009
        outMarc.deleteFields("009");

        // Drop 590
        outMarc.deleteFields("590");

        // Drop 595
        if ( campus == UCSF )
        {
            outMarc.deleteFields("595");
        }

        // Drop 599
        if ( campus == UCR )
        {
            outMarc.deleteFields("599");
        }

        // Drop 850
        outMarc.deleteFields("850");

        // Drop 852
        outMarc.deleteFields("852");

        // Drop 855, 857, 858
        if ( campus == UCSC )
        {
            outMarc.deleteFields("855");
            outMarc.deleteFields("857");
            outMarc.deleteFields("858");
        }

        // Drop 866-868
        outMarc.deleteFields("866", "868");

        // Drop 886
        outMarc.deleteFields("886");

        // Drop 899
        outMarc.deleteFields("899");

        // Drop 9XX (Shouldn't be necessary, but ... )
        outMarc.deleteFields("9XX");
    }


    /**
     * Build MARC 005 field
     */
    private void build005()
    {
        // Get the value of the first 902 $a
        String v902a = inMarc.getFirstValue("902", "a");

        if ( !exists(v902a) )
        {
            // If no 902 $a field found
            // Use file conversion date
            outMarc.getNewFixField("005", fileConvertDate);
        }
        else
        {
            // If 902 $a field found
            // create new 005 field based on 902 $a value
            StringBuffer sb = new StringBuffer(v902a);
            String yr = null;

            // UCR Exception
            if ( campus == UCR )
            {
                // Delete hyphens
                sb.deleteCharAt(2);
                sb.deleteCharAt(4);

                // Move year to front
                yr = sb.substring(4);
                sb.delete(4, 6);
                sb.insert(0, yr);
            }

            // Prepend the century indicator
            yr = sb.substring(0, 2);
            String century = (Integer.parseInt(yr) >= 60 ? "19" : "20");
            sb.insert(0, century);

            // Append hr, min, and sec digits
            sb.append("000000.0");

            // Add new 005 to outMarc
            outMarc.getNewFixField("005", sb.toString());
        }
    }


    /**
     * Create a new MARC 035 field
     */
    private void build035()
    {
        // Get the control number from the 001 if present
        MarcFixedLengthField f001 = (MarcFixedLengthField)inMarc.getFirstField("001");

        if ( f001 == null ) return; // Nothing to do

        String v001 = f001.value();

        // Determine the appropriate control code prefix
        String prefix = null;
        switch ( campus )
        {
        case GTU:
        case UCR:
            prefix = ""; break;
        case UCI:
        case UCSC:
        case UCSD:
        case UCSF:
            prefix = "(OCoLC)"; break;
        case UCDL:
            prefix = "(CStRLIN)"; break;
        default:
            throw new RuntimeException("build035: Unknown campus");
        }

        // Create a new 035 with blank indicators and put the properly
        // prefixed control number in the $a
        MarcVblLengthField f035 = outMarc.getNewVblField("035", "  ");
        f035.addSubfield("a", prefix + v001);
    }

    /**
     * Build MARC 901 field for output record based on input
     * 901. Throw MarcDropException if input 901 is missing.
     */
    private void build901()
    {
        String out901a = null;
        String out901b = null;

        // get the first 901 field
        String in901a = inMarc.getFirstValue("901", "a");

        if ( !exists(in901a) )
        {
            throw new MarcDropException("Input lacks 901 $a");
        }

        // Determine the output 901 $a
        switch ( campus )
        {
        case GTU:
            out901a = "GTB"; break;
        case UCDL:
            out901a = "DLB"; break;
        case UCI:
            out901a = "IRB"; break;
        case UCR:
            out901a = "RVB"; break;
        case UCSC:
            out901a = "SCB"; break;
        case UCSD:
            out901a = "SDB"; break;
        case UCSF:
            out901a = "SFB"; break;
        default:
            throw new RuntimeException("Unknown campus");
        }

        // Compute the index of the first and last characters of the $b data
        int beg901b = prefixForThisCampus().length() + 1;
        int end901b = (( campus == GTU || campus == UCDL )
                       ? in901a.length() - 1
                       : in901a.length());

        if ( log.isDebugEnabled() )
        {
            log.debug("prefix = '" + prefixForThisCampus()
                      + "' in901a = '" + in901a
                      + "' beg901b = " + beg901b
                      + " end901b = " + end901b);
        }

        // The $b portion must contain at least 1 character
        if ( beg901b < end901b )
        {
            // Determine the output 901 $b
            out901b = in901a.substring(beg901b, end901b);
        }
        else
        {
            throw new MarcDropException("Input lacks 901 $b");
        }

        if ( log.isDebugEnabled() )
        {
            log.debug("in901b = '" + out901b + "' length = " + out901b.length());
        }

        // Add the output 901
        MarcVblLengthField out901 = outMarc.getNewVblField("901", "  ");
        out901.addSubfield("a", out901a);
        out901.addSubfield("b", out901b);

        if ( log.isDebugEnabled() )
        {
            log.debug("processing record: " + out901a + "-" + out901b);
        }
    }

}
